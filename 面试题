一、基础组件与核心原理
Activity相关
1. Activity 生命周期
初始化：onCrerate
可见：onStart
获得焦点可交互：onResume
失去焦点，但可见：onPause
不可见  停止：onStop
销毁：onDestory

重新打开：onRestart -> onStart -> onResume


2. onStart 和 onResume 的区别
onStart是可见，onResume 是获得焦点，可以交互。
Activity 被对话框遮挡时会从 onResume 回退到 onPause 而不是onStop


3. Activity 什么时候会执行 onRestart
从停止状态（onStop）重新回到前台，如 home 键返回再重新进入页面，或被其他Activity遮挡后重新显示。


4.如何在 Activity 被销毁前存储数据，onSaveInstanceState 和 onPause 有什么区别
a. 使用 onSaveInstanceState(Bundle outState) 方法：在 Activity 即将被销毁时，系统会调用 onSaveInstanceState 方法。可以在这个方法中将需要保存的数据存储到 Bundle 对象中。这个 Bundle 对象会在Activity被重新创建时传递给 onCreate 方法和 onRestoreInstanceState 方法。

b.使用 SharedPreferences

c.数据库

onSaveInstanceState 在Activity 即将被销毁时，系统会调用 用其保存临时数据，适合轻量数据。
onPause 是 Activity 失去焦点时调用，无论是否销毁只要失去焦点都会执行。


5. Activity的四种启动模式
a. Standard（标准模式）：默认的启动模式。每次启动一个 Activity，都会创建一个新的实例，不管这个 Activity 是否已经存在。
b. SingleTop（单顶模式）：如果要启动的 Activity 已经位于栈顶，那么不会创建新的实例，而是直接使用已存在的实例。如果不在栈顶，则会创建新的实例。
c. SingleTask（单任务模式）：系统会在一个新的任务栈中创建这个 Activity 的实例，并且这个任务栈中只有这一个 Activity 实例。如果要启动的 Activity 已经存在于其他任务栈中，系统会将该任务栈调到前台，并且销毁该Activity上面的所有 Activity 实例。
d. SingleInstance（单实例模式）：类似于 SingleTask，但是 SingleInstance 式的 Activity 实例会独占一个任务栈，不会与其他 Activity 实例共存于同一个任务栈中。

可以通过在 AndroidManifest.xml 文件中的 <activity> 标签中设置 android:launchMode 属性来指定 Activity 的启动模式。


6.如何通过 Intent 传递数据给另一个 Activity，如何返回数据
通过 intent.putExtra 传递数据。
主 Activity 通过 startActivityForResult 启动目标 Activity，目标 Activity 通过 setResult 设置返回值，主 Activity 通过 onActivityResult 方法检查请求码和结果码，获取返回的数据。


7.什么是 Activity 栈，系统如何管理多个Activity的栈结构
Activity 栈（Task）是管理 Activity 的一种数据结构。
启动 Activity 时入栈，按返回键或者执行 finish 方法时出栈，默认一个应用对应一个栈，可以通过 TaskAffinity 属性指定不同栈。


8. Activity 与Fragment 的生命周期有何关联
Fragment 生命周期包括 onAttach、onCreate、onCreateView、onActivityCreated、onStart、onResume、onPause、onStop、onDestroyView、onDestroy和onDetach
当一个 Fragment 被添加到 Activity 中时，它的生命周期会受到 Activity 的生命周期影响。当 Activity 调用 onCreate 方法时，会依次调用 Fragment 的 onAttach、onCreate 和 onCreateView 方法。当Activity 调用 onStart 方法时，会依次调用 Fragment 的 onStart 方法；当 Activity 调用 onResume 方法时，会依次调用 Fragment 的 onResume 方法。


9.如何避免屏幕旋转导致的 Activity 重建问题
在 Manifest 中配置 android:configChanges = "orientation|screenSize" （告诉系统不要重建 Activity，而是调用 onConfigurationChanged 方法。） ,让系统不重建 Activity；或用 viewModel 保存数据，使生命周期独立于 Activity。


10.什么是 TaskAffinity，它如何影响 Activity 的栈管理
TaskAffinity 是 Activity 的一个属性，默认与应用包名一致。如果Activity 的 TaskAffinity 属性与其所在任务栈的 TaskAffinity 属性不同，该 Activity 将被放入指定的任务栈中。


Service相关
11. Service 和 Thread 的本质区别是什么
Service 是一种在操作系统中运行的后台进程，Thread （线程）是程序执行的最小单位，它是进程中的一个实体，负责执行程序中的指令，一个进程可以包含多个线程。
Service 本身不实现多线程，需要在内部创建 Thread


12. startService 与 bindService 两种启动方式的生命周期有何不同
startService 启动后生命周期为 onCreate -> onStartCommand -> onDestory ,需显示停止，即使启动服务的组件（如 Activity）被销毁，服务仍然会继续运行。
bindService 则是 onCreate -> onBind -> onUnbind ->onDestory，随绑定组件生命周期结束而销毁，支持双向通信。


13.如何保证 Service 在后台被杀死后能自动重启
在 onStartCommand 返回 START_STICKY 或 START_REDELIVER_INTENT ，系统会在内存充足时重启 Service；或使用前台服务，通过通知提升优先级。或在服务的 onDestory 方法中设置一个定时任务。


14. 前台服务和普通服务有什么区别
前台服务必须显示通知，优先级高（不易被杀死），用于用户可感知的后台任务（如音乐播放）；普通服务优先级低，系统内存不足时可能被回收。


15. IntentService 的特点是什么
IntentService 是 Service 的子类，内部有工作线程处理任务，任务完成后自动停止，无需手动管理线程和生命周期，适合一次性后台任务（如下载单个文件）。


16. Service 的 onStartCommand 方法，返回值有哪些类型
START_STICKY（重启后不保留 Intent）、START_NOT_STICKY（不自动重启）、START_REDELIVER_INTENT（重启后重发 Intent）。


17.如何在 Service 和 Activity 之间进行双向通信
a.使用绑定 Service （bindService） 和回调接口
b.使用 Messenger 
c.使用 BroadcastReceiver（广播）
d.使用 LiveData 和 ViewModel


18.为什么不建议在 Service 中执行耗时操作
Service 默认运行在主线程，耗时操作会导致 ANR（应用无响应）。正确做法是在 Service 中创建子线程，或使用 IntentService/WorkManager。


19.如何防止 Service 被系统回收
常用策略：提升为前台服务、重写 onStartCommand 返回 START_STICKY、通过 AlarmManager 定时唤醒、使用双 Service 互相守护（不推荐，影响用户体验）。


20.远程 Service 和本地 Service 的区别是什么
本地 Service 与应用在同一进程，通信快（直接调用）；远程 Service 独立进程，需通过 AIDL 跨进程通信，适合给其他应用提供服务，开销较大。


BroadcastReceiver 相关
21.广播的两种注册方式有什么区别
静态注册（Manifest 声明）：应用未启动也能接收，耗电，Android 8.0 后对隐式广播限制严格；动态注册（代码中注册）：随组件生命周期，灵活可控，需手动注销。


22.Android 8.0 后对静态广播有哪些限制
8.0 后静态注册无法接收大部分隐式广播，需使用显式广播（指定包名）或动态注册，系统广播（如开机完成）不受影响。


23.有序广播和无序广播的区别是什么
有序广播按优先级接收，可被拦截（abortBroadcast ()）和修改数据；无序广播所有接收者同时收到，无法拦截，效率高。


24.本地广播和全局广播的区别是什么
本地广播（LocalBroadcastManager）仅在应用内传播，安全高效；全局广播可跨应用，存在安全风险（如数据泄露）。


25.如何防止广播被恶意接收或发送
发送时指定权限（sendBroadcast (intent, permission)），接收时在 Manifest 声明对应权限；使用显式广播，避免隐式广播被滥用。


26.系统常见的广播事件有哪些
如开机完成（ACTION_BOOT_COMPLETED）、网络变化（ACTION_CONNECTIVITY_CHANGE）、电量低（ACTION_BATTERY_LOW）、安装应用（ACTION_PACKAGE_ADDED）等。


27.动态广播为什么必须在 onDestroy () 中注销
若不注销，广播接收器会持有 Activity 引用，导致内存泄漏；Activity 销毁后，接收器仍可能接收事件，引发空指针异常


ContentProvider 相关
28.ContentProvider 的核心作用是什么
提供跨进程数据共享的标准化接口，通过 ContentProvider，应用程序可以将自己的数据暴露给其他应用程序访问，实现数据共享和数据交互，访问应用程序的数据库、文件系统或网络数据，和应用间数据共享。提供了一种统一的方式来管理和访问数据，保证数据的安全性和一致性。


29.如何实现一个自定义 ContentProvider
继承 ContentProvider，实现 query/insert/update/delete/getType 方法，在 Manifest 中注册并指定 authority，通过 Uri 匹配器（UriMatcher）处理不同请求。


30.ContentResolver 和 ContentProvider
ContentResolver 是客户端访问数据的入口，通过 Uri 统一调用不同 ContentProvider 的方法，隐藏具体实现，实现解耦。


31.Uri 的结构是什么
格式为 content://authority/path/id，如 content://com.example.provider/user/1，其中 authority 是唯一标识，path 表示数据集合，id 是具体记录。


32.系统提供了哪些常用的 ContentProvider
联系人（ContactsContract）、媒体库（MediaStore）、日历（CalendarContract）、下载管理（Downloads）等。


二、布局与 UI 渲染
布局与控件
33.LinearLayout、RelativeLayout 和 ConstraintLayout 的性能对比如何
LinearLayout（单方向）测量效率最高，适合简单布局；RelativeLayout 灵活性高，可能需两次测量，复杂布局性能较差；ConstraintLayout 通过约束实现扁平化，性能优于 RelativeLayout，适合复杂 UI。


34.什么是过度绘制，如何优化
过度绘制指同一像素被多次绘制（如多层背景叠加）。优化：移除冗余背景、减少布局嵌套、使用 clipRect () 限制绘制区域、通过开发者选项开启过度绘制检测。


35.如何减少布局层级
用 ConstraintLayout 替代多层嵌套、使用 merge 标签合并根布局、用 ViewStub 延迟加载非必要布局、避免不必要的 ViewGroup 嵌套。


36.ViewStub 的作用是什么
ViewStub 是轻量级占位控件，默认不加载，需时通过 inflate () 加载布局，适合条件显示的 UI（如空数据提示），减少初始布局加载时间。


37.自定义 View 的基本流程是什么
继承 View 或现有控件，重写构造方法（解析属性），重写 onMeasure（测量尺寸），重写 onDraw（绘制内容），必要时重写 onTouchEvent（处理触摸）。


38.View 的测量模式有哪些
EXACTLY（精确尺寸，如 match_parent 或固定值）、AT_MOST（最大尺寸，如 wrap_content）、UNSPECIFIED（无限制，如 ScrollView 中的子 View）。


39.SurfaceView 和普通 View 的区别是什么
SurfaceView 有独立绘图表面，在子线程绘制，适合高频刷新（如视频、游戏）；普通 View 在主线程绘制，刷新频繁会卡顿。


绘制原理
40.View 的绘制流程包含哪三个核心步骤
测量（onMeasure，确定尺寸）→ 布局（onLayout，确定位置）→ 绘制（onDraw，绘制内容）。父 View 会递归调用子 View 的这三个方法。


41.什么是 View 树，系统如何遍历 View 树进行绘制
View 树是由 ViewGroup 和 View 组成的层级结构。系统通过深度优先遍历，先绘制父 View，再绘制子 View，确保子 View 覆盖在父 View 之上。


42.硬件加速的原理是什么，哪些情况下需要关闭
硬件加速利用 GPU 处理绘制，提升性能。但部分绘制操作（如 PathEffect、LayerType.SOFTWARE）不支持硬件加速，需在 View 级别关闭。


43.什么是 Choreographer
Choreographer 协调 UI 绘制、输入和动画，与屏幕刷新率同步（通常 60fps），确保绘制在每一帧的正确时机执行，避免卡顿。


44.View 的事件分发机制中三个核心方法是什么
dispatchTouchEvent（分发事件）、onInterceptTouchEvent（拦截事件，仅 ViewGroup 有）、onTouchEvent（处理事件）。流程：先分发，再判断是否拦截，最后处理。


45.如何解决滑动冲突
常见方案：在父 View 的 onInterceptTouchEvent 中根据滑动方向判断是否拦截；或子 View 通过 requestDisallowInterceptTouchEvent () 请求父 View 不拦截。


三、性能优化
内存优化
46.常见的内存泄漏场景有哪些
单例持有 Activity 上下文、未取消的监听器（如 BroadcastReceiver、EventBus）、Handler 匿名内部类持有 Activity 引用、资源未关闭（流、Cursor）、静态集合持有对象。


47.什么是内存抖动，如何解决
内存抖动指短时间频繁创建和回收对象（如循环中创建对象），导致 GC （垃圾回收）频繁触发。解决：复用对象、使用对象池、避免在 onDraw () 中创建对象。


48.LRU 缓存机制的原理是什么
LRU算法优先淘汰最久未使用的对象，通过 LinkedHashMap 实现，适用于图片缓存（如 Glide）、内存数据缓存。


49.如何优化 Bitmap 的内存占用
根据控件尺寸加载对应分辨率图片（inSampleSize）、使用适当格式（如 WebP）、及时回收（recycle ()）、使用缓存、通过 Glide 等库自动管理。


50.弱引用、软引用和强引用的区别是什么
强引用（默认）：GC 不会回收；软引用（SoftReference）：内存不足时回收，适合缓存；弱引用（WeakReference）：GC 触发时回收，适合临时对象。


启动与响应优化
51.冷启动、热启动和温启动的区别是什么
冷启动：进程首次创建，需初始化 Application 和 Activity，耗时最长；热启动：进程存在，Activity 未销毁，直接恢复；温启动：进程存在，但 Activity 需重建，耗时介于两者之间。


52.如何优化应用启动速度
减少 Application onCreate () 中的初始化（延迟非核心任务）、优化首屏布局（减少层级、避免过度绘制）、使用启动主题避免白屏、异步加载数据、启用 R8 混淆缩减代码。


53.什么是 ANR，如何避免
ANR（应用无响应）指主线程阻塞超过一定时间（输入事件 5 秒，广播 10 秒，服务 20 秒）。避免：耗时操作放子线程；使用 AsyncTask/HandlerThread/Coroutine；减少布局复杂度；避免在主线程中执行可能会阻塞线程的操作，如网络请求、数据库操作等。


54.如何检测 ANR 问题
通过 Logcat 查看 ANR 日志（data/anr/traces.txt）、使用 Android Vitals 监控、自定义 ANR 监控（如通过 Handler 定时检测主线程响应）。


55.启动优化中如何使用 IdleHandler
IdleHandler 在主线程空闲时执行，可用于延迟初始化非核心组件（如统计、推送），避免占用启动时间：Looper.myQueue ().addIdleHandler (() -> { ...; return false; })。


列表与网络优化
56.RecyclerView 相比 ListView 有哪些优势
RecyclerView 更灵活，通过 LayoutManager 支持多种布局（线性、网格、瀑布流）、强制使用 ViewHolder、支持动画、可自定义 ItemDecoration 和 ItemAnimator。


57.RecyclerView 的优化策略有哪些
复用 ViewHolder、减少布局层级、图片懒加载（滑动时暂停）、使用 DiffUtil 更新数据、设置固定高度（setHasFixedSize (true)）、优化 onBindViewHolder（避免耗时操作）。


58.DiffUtil 的作用是什么
DiffUtil 通过比对新旧数据集，计算差异并更新变化的 Item，替代 notifyDataSetChanged ()，减少不必要的刷新，提升性能和动画效果。


59.如何优化网络请求
合并请求、使用缓存（OkHttp 缓存）、压缩数据（Gzip）、图片懒加载、使用 Retrofit+OkHttp 的拦截器统一处理、避免重复请求、根据网络类型（WiFi / 移动网络）调整策略。


60.列表滑动卡顿的常见原因有哪些
布局层级过深、Item 布局复杂、onBindViewHolder 中执行耗时操作、图片未优化（过大或未缓存）、过度绘制、主线程做网络 / IO 操作。


四、数据存储与安全
数据存储
61.Android 中有哪些数据存储方式
SharedPreferences（键值对，轻量）、文件存储（内部 / 外部存储）、SQLite 数据库（结构化数据，Room 封装）、ContentProvider（跨应用共享）、网络存储（服务器）。


62.SharedPreferences 的使用注意事项是什么
不适合存储大量数据、线程不安全（多进程需用 MODE_MULTI_PROCESS，已废弃，建议用 ContentProvider）、commit () 同步提交，apply () 异步提交（可能丢失）。


63.Room 框架的优势是什么
Room 是 SQLite 的封装，提供编译时语法检查、简化 CRUD 操作、支持 LiveData 和 RxJava 响应式查询、减少模板代码，避免手写 SQL 错误。


64.内部存储和外部存储的区别是什么
内部存储：私有（仅本应用访问）、应用卸载时删除、无需权限；外部存储：分为公共目录（所有应用可访问）和私有目录（Android/data/ 包名，卸载删除），访问公共目录需权限。


65.Android 10 的分区存储（Scoped Storage）是什么
分区存储限制应用直接访问外部存储根目录，需通过 MediaStore 访问公共媒体文件，或使用应用私有目录，增强用户隐私保护，Android 11 后强制启用。


安全与权限
66.Android 权限分为哪几类
正常权限（如 INTERNET，自动授予）、危险权限（如 CAMERA，需动态申请）、特殊权限（如 SYSTEM_ALERT_WINDOW，需跳转设置页面申请）。


67.如何请求危险权限
检查是否已授权（checkSelfPermission ()），未授权则请求（requestPermissions ()），在 onRequestPermissionsResult () 中处理结果，必要时显示权限说明（shouldShowRequestPermissionRationale ()）。


68.如何加密存储敏感数据
使用 AndroidKeystore 存储密钥、AES 加密数据、SharedPreferences 加密（如 EncryptedSharedPreferences）、避免明文存储密码（用哈希 + 盐值）。


69.如何防止应用被反编译
启用 Proguard/R8 混淆代码、使用加固工具（如 360 加固）、敏感逻辑用 C++ 实现（NDK）、检测调试状态（Debug.isDebuggerConnected ()）。


70.网络传输中如何保证数据安全
使用 HTTPS（TLS）、证书校验（避免中间人攻击）、数据加密后传输、敏感参数不放在 URL 中、使用 OKHttp 的 SSLSocketFactory 配置安全连接。


五、框架与第三方库
Jetpack 组件
71.ViewModel 的作用是什么
ViewModel 存储与 UI 相关的数据，生命周期独立于 Activity/Fragment，解决屏幕旋转等配置变化时的数据丢失问题，通常与 LiveData 配合使用。


72.LiveData 的特点是什么
LiveData 是可观察的数据持有者，能感知生命周期，仅在 Activity/Fragment 处于活跃状态时通知更新，避免内存泄漏，支持数据粘性（新观察者能收到旧数据）。


73.DataBinding 的优势是什么
DataBinding 将布局与数据直接绑定，减少 findViewById () 代码，支持双向绑定（@={}），可在 XML 中写简单逻辑，提升开发效率。


74.WorkManager 的作用是什么
WorkManager 管理后台任务（如同步数据），兼容不同 Android 版本，根据设备状态（充电、网络、空闲）智能调度，支持周期性任务和链式任务。


75.Navigation 组件如何管理页面跳转
Navigation 通过导航图（nav_graph.xml）集中管理页面关系，支持 Fragment 和 Activity 跳转，自动处理回退栈，可通过 Safe Args 传递参数，避免类型错误。


网络与图片
76.Retrofit 的工作原理是什么
Retrofit 通过动态代理将接口方法转换为 OKHttp 请求，解析注解（如 @GET、@POST）生成请求参数和 URL，通过 ConverterFactory 解析响应数据（如 Gson），CallAdapter 转换返回类型（如 Observable）。


77.OkHttp 的拦截器有什么作用
拦截器用于在请求发送前或响应返回后处理（如添加公共参数、日志打印、缓存控制、token 过期重试），分为应用拦截器和网络拦截器。


78.Glide 的三级缓存机制是什么
内存缓存（LruCache + 弱引用，最快）→ 磁盘缓存（原始图片 + 处理后图片，持久化）→ 网络请求（最慢）。加载图片时依次检查三级缓存，未命中则从网络获取。


79.Glide 如何实现图片的高效加载
自动根据 ImageView 尺寸加载对应分辨率图片、支持内存和磁盘缓存、使用线程池管理加载任务、生命周期感知（避免 Activity 销毁后仍加载）、自动回收资源。


80.RxJava 的背压是什么
背压指生产者发送数据速度快于消费者处理速度的问题，RxJava 通过 Flowable 和 Subscriber 支持背压策略（如缓冲、丢弃、错误），控制数据流速。


六、高级特性与现代开发
Compose 相关
81.什么是Compose
Jetpack Compose是一种用于构建用户界面的现代工具包，专为Android应用程序开发而设计。它使用Kotlin编程语言，允许开发者使用声明式方式构建用户界面，而不是传统的XML布局文件。


82.什么是 Composable 函数
Composable 是 Compose 中用于构建 UI 的函数，用 @Composable 注解标记，可嵌套调用，系统会根据状态变化自动重组（重新执行）需要更新的部分。


83.Compose 的重组机制是什么
重组是 Compose 根据状态变化重新执行部分 UI 代码的过程，只更新变化的组件，而非整个 UI 树，通过 remember 保存状态，避免不必要的重组。


84.如何在 Compose 中管理状态
使用 remember 保存临时状态，viewModel () 获取 ViewModel 中的状态，状态提升（将子组件状态移至父组件）实现状态共享，使用 StateFlow 管理跨组件状态。


85.Compose 和传统 View 如何混编
在 Compose 中用 AndroidView 包裹传统 View，在传统布局中用 ComposeView 承载 Compose 内容，适合渐进式迁移。


86.Compose 中的副作用有哪些处理方式
LaunchedEffect（协程中执行副作用，如网络请求）、DisposableEffect（需要清理的副作用，如注册监听器）、SideEffect（每次重组都执行，如更新全局状态）。


系统特性与适配
87.Android 12 的 Material You 设计语言有哪些特点
支持动态色彩（从壁纸提取主题色）、圆角设计、新的组件样式（如 Button、Card）、手势导航增强、应用启动动画规范。


88.如何适配折叠屏设备
检测屏幕状态（展开 / 折叠）、使用 Jetpack WindowManager 获取屏幕信息、避免硬编码尺寸、测试多窗口模式、适配不同折叠形态（如内折、外折）。


89.如何适配暗黑模式
在 styles.xml 中定义 DayNight 主题，使用？attr / 引用主题属性，在 res/values-night 目录下定义暗黑模式资源，支持用户手动切换模式。


90.Android 13 对权限有哪些变更
通知权限需动态申请、媒体权限细分（图片、视频、音频）、剪贴板访问限制、精确位置权限需单独申请。


91.什么是应用休眠（App Hibernation）
Android 13 引入，长期未使用的应用会被标记为休眠状态，系统限制其后台活动和网络访问，需在 Manifest 中声明豁免或提示用户打开应用解除休眠。


七、测试与调试
92.单元测试和 instrumentation 测试有何区别
单元测试（如 JUnit）在本地 JVM 运行，测试独立组件，速度快；instrumentation 测试（如 Espresso）在设备 / 模拟器运行，测试组件交互，依赖 Android 框架。


93.Espresso 框架的作用是什么
Espresso 用于 UI 测试，提供简洁 API（onView ().perform ().check ()），自动处理主线程同步，支持匹配器（Matcher）定位 View，验证 UI 状态。


94.Mockito 的作用是什么？
Mockito 是 mocking 框架，用于创建模拟对象（如网络请求、数据库），隔离测试对象，验证方法调用，设置返回值，简化单元测试。


95.如何测试异步代码
使用 CountDownLatch 等待异步完成、RxJava 的 TestSubscriber、Coroutine 的 runBlockingTest、Espresso 的 IdlingResource 处理异步加载。


96.什么是 UI Automator
UI Automator 用于跨应用 UI 测试，可操作系统控件（如通知栏、设置），适合端到端测试，支持通过文本、描述等定位元素。


调试与工具
97.ADB 有哪些常用命令
安装应用（adb install）、卸载（adb uninstall）、查看日志（adb logcat）、重启（adb reboot）、查看设备（adb devices）、截图（adb shell screencap）、录屏（adb shell screenrecord）。


98.Android Profiler 的主要功能是什么
Android Profiler 包含 CPU（分析方法耗时）、内存（检测泄漏）、网络（监控请求）、电量（分析耗电）分析工具，实时监控应用性能。


99.如何使用 Layout Inspector 分析布局问题
Layout Inspector 可实时查看应用的 View 树结构、属性和测量信息，识别过度绘制、层级过深等问题，支持 3D 视图查看布局层次。


100.什么是 systrace
systrace 用于分析系统级性能问题，记录 CPU 调度、UI 渲染、进程状态等信息，生成 HTML 报告，可识别掉帧、锁竞争等瓶颈。


101.LeakCanary 的工作原理是什么
LeakCanary 在 Activity/Fragment 销毁后，通过弱引用检测是否被回收，未回收则触发 GC 并分析堆内存，生成泄漏路径报告，帮助定位内存泄漏。
