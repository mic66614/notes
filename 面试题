一、基础组件与核心原理
Activity相关
1. Activity 生命周期
初始化：onCrerate
可见：onStart
获得焦点可交互：onResume
失去焦点，但可见：onPause
不可见  停止：onStop
销毁：onDestory

重新打开：onRestart -> onStart -> onResume


2. onStart 和 onResume 的区别
onStart是可见，onResume 是获得焦点，可以交互。
Activity 被对话框遮挡时会从 onResume 回退到 onPause 而不是onStop


3. Activity 什么时候会执行 onRestart
从停止状态（onStop）重新回到前台，如 home 键返回再重新进入页面，或被其他Activity遮挡后重新显示。


4.如何在 Activity 被销毁前存储数据，onSaveInstanceState 和 onPause 有什么区别
a. 使用 onSaveInstanceState(Bundle outState) 方法：在 Activity 即将被销毁时，系统会调用 onSaveInstanceState 方法。可以在这个方法中将需要保存的数据存储到 Bundle 对象中。这个 Bundle 对象会在Activity被重新创建时传递给 onCreate 方法和 onRestoreInstanceState 方法（调用在onStart之后）。
b.使用 SharedPreferences
c.数据库
onSaveInstanceState 在Activity 即将被销毁时，此方法调用在onStop之前，系统会调用，用其保存临时数据，适合轻量数据。
onPause 是 Activity 失去焦点时调用，无论是否销毁只要失去焦点都会执行。


5. Activity的四种启动模式
a. Standard（标准模式）：默认的启动模式。每次启动一个 Activity，都会创建一个新的实例，不管这个 Activity 是否已经存在。
b. SingleTop（单顶模式）：如果要启动的 Activity 已经位于栈顶，那么不会创建新的实例，而是直接使用已存在的实例。如果不在栈顶，则会创建新的实例。
c. SingleTask（单任务模式）：系统会在一个新的任务栈中创建这个 Activity 的实例，并且这个任务栈中只有这一个 Activity 实例。如果要启动的 Activity 已经存在于其他任务栈中，系统会将该任务栈调到前台，并且销毁该Activity上面的所有 Activity 实例。
d. SingleInstance（单实例模式）：类似于 SingleTask，但是 SingleInstance 式的 Activity 实例会独占一个任务栈，不会与其他 Activity 实例共存于同一个任务栈中。

可以通过在 AndroidManifest.xml 文件中的 <activity> 标签中设置 android:launchMode 属性来指定 Activity 的启动模式。


6.如何通过 Intent 传递数据给另一个 Activity，如何返回数据
通过 intent.putExtra 传递数据。
主 Activity 通过 startActivityForResult 启动目标 Activity，目标 Activity 通过 setResult 设置返回值，主 Activity 通过 onActivityResult 方法检查请求码和结果码，获取返回的数据。


7.什么是 Activity 栈，系统如何管理多个Activity的栈结构
Activity 栈（Task）是管理 Activity 的一种数据结构。
启动 Activity 时入栈，按返回键或者执行 finish 方法时出栈，默认一个应用对应一个栈，可以通过 TaskAffinity 属性指定不同栈。


8. Activity 与Fragment 的生命周期有何关联
Fragment 生命周期包括 onAttach、onCreate、onCreateView、onActivityCreated、onStart、onResume、onPause、onStop、onDestroyView、onDestroy和onDetach
当一个 Fragment 被添加到 Activity 中时，它的生命周期会受到 Activity 的生命周期影响。当 Activity 调用 onCreate 方法时，会依次调用 Fragment 的 onAttach、onCreate 和 onCreateView 方法。当Activity 调用 onStart 方法时，会依次调用 Fragment 的 onStart 方法；当 Activity 调用 onResume 方法时，会依次调用 Fragment 的 onResume 方法。


9.如何避免屏幕旋转导致的 Activity 重建问题
在 Manifest 中配置 android:configChanges = "orientation|screenSize" （告诉系统不要重建 Activity，而是调用 onConfigurationChanged 方法。） ,让系统不重建 Activity；或用 viewModel 保存数据，使生命周期独立于 Activity。


10.什么是 TaskAffinity，它如何影响 Activity 的栈管理
TaskAffinity 是 Activity 的一个属性，默认与应用包名一致。如果Activity 的 TaskAffinity 属性与其所在任务栈的 TaskAffinity 属性不同，该 Activity 将被放入指定的任务栈中。


11. Activity A 启动另一个Activity B 会调用哪些方法，如果B是透明主题的又或则是个DialogActivity呢
Activity A 启动另一个Activity B，回调如下
Activity A 的onPause() → Activity B的onCreate() → onStart() → onResume() → Activity A的onStop()；
如果B是透明主题的又或则是个DialogActivity时：则不会回调A的onStop


12. Activity 横竖屏切换的生命周期
manifest文件中不配置android:configChanges属性时： 
Activity启动时： onCreate，onStart，onResume
屏幕切换的时候：onPause，onSaveInstanceState，onStop，onDestroy，onCreate，onStart，onRestoreInstanceState，onResume

配置android:configChanges属性的时：
android:configChanges=”orientation|screenSize” 
调用：onConfigurationChanged


13.跨App启动Activity的方式,注意事项
在Android开发中，跨App启动Activity需要使用Intent的特殊标志FLAG_ACTIVITY_NEW_TASK以及对应的权限声明。
解决方案：
(1)在启动Activity的App中，设置Intent的FLAG_ACTIVITY_NEW_TASK标志。
(2在被启动的Activity的AndroidManifest.xml中，将<activity>标签的android:launchMode属性设置为"singleTask"，以确保启动新任务。
(3)被启动App的Manifest文件中需要声明相应的权限，以允许其他App启动其组件。

注意事项：
(1)确保被启动App已经安装在设备上。
(2)被启动App需要有一个能够匹配启动Intent的<intent-filter>。
(3)确保启动Activity的App有权限启动其他App的组件，这通常需要自定义权限并在被启动App中声明。
(4)如果被启动的App和Activity使用了更加严格的安全设置，可能需要额外的签名认证或者密码保护。

14.谈Activity和Fragment的区别
相似点：都可包含布局、可有自己的生命周期
不同点：
        a.Fragment相比较于Activity多出5个生命周期，在控制操作上更灵活；
        s.Fragment可以在XML文件中直接进行写入，也可以在Activity中动态添加；
        c.Fragment可以使用show()/hide()或者replace()随时对Fragment进行切换，并且切换的时候不会出现明显的效果，用户体验会好；Activity虽然也可以进行切换，但是Activity之间切换会有明显的翻页或者其他的效果，在小部分内容的切换上给用户的感觉不是很好；
        d.Activity代表了一个具有用户界面的屏幕。而Fragment是Activity内的一个可重用部件，可以在多个Activity中重复使用，有助于构建灵活且适应不同屏幕尺寸的用户界面


15.Fragment中add与replace的区别
add 将 Fragment 添加到容器中,叠加显示
replace 替换容器中现有的Fragment，替换显示


16.getFragmentManager、getSupportFragmentManager 、getChildFragmentManager之间的区别
a. getFragmentManager用于获取Activity中托管的Fragment的FragmentManager。
b. getSupportFragmentManager用于获取FragmentActivity中托管的Fragment的SupportFragmentManager，Android3.0以下需要使用此方法。
c. getChildFragmentManager(用于获取当前Fragment中托管的子Fragment的FragmentManager。


17.FragmentPagerAdapter与FragmentStatePagerAdapter的区别与使用场景
相同点 ：二者都继承PagerAdapter
不同点 ：
FragmentPagerAdapter的每个Fragment会持久的保存在FragmentManager中，只要用户可以返回到页面中，它都不会被销毁。因此适用于那些数据相对静态的页，Fragment数量也比较少的那种；
FragmentStatePagerAdapter只保留当前页面，当页面不可见时，该Fragment就会被消除，释放其资源。因此适用于那些数据动态性较大、占用内存较多，多Fragment的情况；


18.Activity的通信方式有哪些
Intent
Bundle
startActivityForResult
BroadcastReceiver
SharedPreference
ViewModel
EventBus
接口回调
ContentProvider


19.Bundle传递对象为什么需要序列化，Serialzable和Parcelable的区别
因为bundle传递数据时只支持基本数据类型，所以在传递对象时需要序列化转换成可存储或可传输的本质状态（字节流）。序列化后的对象可以在网络、IPC（比如启动另一个进程的Activity、Service和Reciver）之间进行传输，也可以存储到本地。
序列化实现的两种方式：实现Serializable/Parcelable接口。
Serializable：是 Java 的原生序列化接口（`java.io.Serializable`），通过 Java 反射机制自动完成序列化和反序列化，性能较低。
Parcelable：是 Android 提供的接口（`android.os.Parcelable`），开发者需要手动实现 writeToParcel 和 describeContents 方法，并定义 CREATOR 静态字段，性能较高。


20.Android里的Intent传递的数据有大小限制吗，什么原因，如何解决
Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。
原因：Intent不仅仅用于传递数据，还负责组件的查找和调用，如果数据过大，可能会导致Intent体积过大，超出了系统的限制，会静默崩溃。
解决方案：
进程内：EventBus，文件缓存、磁盘缓存。
进程间：通过ContentProvider进行款进程数据共享和传递


21.如何理解Activity，View，Window三者之间的关系
Activity作为Android应用程序的一个组件，负责管理界面的生命周期和交互逻辑；View作为界面的基本构建块，代表屏幕上的可视元素；Window作为Activity的关联对象，负责承载和展示界面内容。它们之间的关系是：Activity通过关联的Window来展示界面内容，而界面内容则由多个View组成。


22.ActivityA跳转ActivityB的过程中，ActivityB 按back键呢
A跳转B：A.onPause －> B.onCreate －> B.onStart－> B.onResume－> A.onStop 
按back键：B.onPause－>A.onRestart－>A.onStart－>A.onResume－>B.onStop－>B.onDestory


23.onCreat()和onRestoreInstanceState()恢复数据区别
a.因为onSaveInstanceState 不一定会被调用，所以onCreate()里的Bundle参数可能为空，如果使用onCreate()来恢复数据，一定要做非空判断。而onRestoreInstanceState的Bundle参数一定不会是空值，因为它只有在上次activity被回收了才会调用。
b.onRestoreInstanceState是在onStart()之后被调用的。有时候我们需要onCreate()中做的一些初始化完成之后再恢复数据，用onRestoreInstanceState会比较方便。


Service相关
11. Service 和 Thread 的本质区别是什么
Service 是一种在操作系统中运行的后台进程，Thread （线程）是程序执行的最小单位，它是进程中的一个实体，负责执行程序中的指令，一个进程可以包含多个线程。
Service 本身不实现多线程，需要在内部创建 Thread


12. startService 与 bindService 两种启动方式的生命周期有何不同
bind:绑定
startService 启动后生命周期为 onCreate -> onStartCommand -> onDestory ,需显示停止，即使启动服务的组件（如 Activity）被销毁，服务仍然会继续运行。
bindService 则是 onCreate -> onBind -> onUnbind ->onDestory，随绑定组件生命周期结束而销毁，支持双向通信。


13.如何保证 Service 在后台被杀死后能自动重启
在 onStartCommand 返回 START_STICKY 或 START_REDELIVER_INTENT ，系统会在内存充足时重启 Service；或使用前台服务，通过通知提升优先级。或在服务的 onDestory 方法中设置一个定时任务。


14. 前台服务和普通服务有什么区别
前台服务必须显示通知，优先级高（不易被杀死），用于用户可感知的后台任务（如音乐播放）；普通服务优先级低，系统内存不足时可能被回收。


15. IntentService 的特点是什么
IntentService 是 Service 的子类，内部有工作线程处理任务，任务完成后自动停止，无需手动管理线程和生命周期，适合一次性后台任务（如下载单个文件）。


16. Service 的 onStartCommand 方法，返回值有哪些类型
START_STICKY（重启后不保留 Intent）、START_NOT_STICKY（不自动重启）、START_REDELIVER_INTENT（重启后重发 Intent）。


17.如何在 Service 和 Activity 之间进行双向通信
a.使用绑定 Service （bindService） 和回调接口
b.使用 Messenger 
c.使用 BroadcastReceiver（广播）
d.使用 LiveData 和 ViewModel


18.为什么不建议在 Service 中执行耗时操作
Service 默认运行在主线程，耗时操作会导致 ANR（应用无响应）。正确做法是在 Service 中创建子线程，或使用 IntentService/WorkManager。


19.如何防止 Service 被系统回收
常用策略：提升为前台服务、重写 onStartCommand 返回 START_STICKY、通过 AlarmManager 定时唤醒、使用双 Service 互相守护（不推荐，影响用户体验）。


20.远程 Service 和本地 Service 的区别是什么
本地 Service 与应用在同一进程，通信快（直接调用）；远程 Service 独立进程，需通过 AIDL 跨进程通信，适合给其他应用提供服务，开销较大。


11.能否在Service开启耗时操作 ， 怎么做  
Service默认并不会运行在子线程中，也不运行在一个独立的进程中，它同样执行在主线程中（UI线程）。换句话说，不要在Service里执行耗时操作，除非手动打开一个子线程，否则有可能出现主线程被阻塞（ANR）的情况； 


12.了解ActivityManagerService吗，发挥什么作用
ActivityManagerService是Android中最核心的服务 ， 主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块类似； 


BroadcastReceiver 相关
21.广播的两种注册方式有什么区别
静态注册（Manifest 声明）：应用未启动也能接收，耗电，Android 8.0 后对隐式广播限制严格；动态注册（代码中注册）：随组件生命周期，灵活可控，需手动注销。


22.Android 8.0 后对静态广播有哪些限制
8.0 后静态注册无法接收大部分隐式广播，需使用显式广播（指定包名）或动态注册，系统广播（如开机完成）不受影响。


23.有序广播和无序广播的区别是什么
有序广播按优先级接收，可被拦截（abortBroadcast ()）和修改数据；无序广播所有接收者同时收到，无法拦截，效率高。


24.本地广播和全局广播的区别是什么
本地广播（LocalBroadcastManager）仅在应用内传播，安全高效；全局广播可跨应用，存在安全风险（如数据泄露）。


25.如何防止广播被恶意接收或发送
发送时指定权限（sendBroadcast (intent, permission)），接收时在 Manifest 声明对应权限；使用显式广播，避免隐式广播被滥用。


26.系统常见的广播事件有哪些
如开机完成（ACTION_BOOT_COMPLETED）、网络变化（ACTION_CONNECTIVITY_CHANGE）、电量低（ACTION_BATTERY_LOW）、安装应用（ACTION_PACKAGE_ADDED）等。


27.动态广播为什么必须在 onDestroy () 中注销
若不注销，广播接收器会持有 Activity 引用，导致内存泄漏；Activity 销毁后，接收器仍可能接收事件，引发空指针异常


ContentProvider 相关
28.ContentProvider 的核心作用是什么
提供跨进程数据共享的标准化接口，通过 ContentProvider，应用程序可以将自己的数据以Uri的形式暴露给其他应用程序访问，实现数据共享和数据交互，访问应用程序的数据库、文件系统或网络数据，和应用间数据共享。提供了一种统一的方式来管理和访问数据，保证数据的安全性和一致性。


29.如何实现一个自定义 ContentProvider
继承 ContentProvider，实现 query/insert/update/delete/getType 方法，在 Manifest 中注册并指定 authority，通过 Uri 匹配器（UriMatcher）处理不同请求。


30.ContentResolver 和 ContentProvider
ContentResolver 是客户端访问数据的入口，通过 Uri 统一调用不同 ContentProvider 的方法，隐藏具体实现，实现解耦。


31.Uri 的结构是什么
格式为 content://authority/path/id，如 content://com.example.provider/user/1，其中 authority 是唯一标识，path 表示数据集合，id 是具体记录。


32.系统提供了哪些常用的 ContentProvider
联系人（ContactsContract）、媒体库（MediaStore）、日历（CalendarContract）、下载管理（Downloads）等。


二、布局与 UI 渲染
布局与控件
1.LinearLayout、RelativeLayout 和 ConstraintLayout 的性能对比如何
LinearLayout（单方向）测量效率最高，适合简单布局；RelativeLayout 灵活性高，可能需两次测量，复杂布局性能较差；ConstraintLayout 通过约束实现扁平化，性能优于 RelativeLayout，适合复杂 UI。


2.什么是过度绘制，如何优化
过度绘制指同一像素被多次绘制（如多层背景叠加）。优化：移除冗余背景、减少布局嵌套、使用 clipRect () 限制绘制区域、通过开发者选项开启过度绘制检测。


3.如何减少布局层级
用 ConstraintLayout 替代多层嵌套、使用 merge 标签合并根布局、用 ViewStub 延迟加载非必要布局、避免不必要的 ViewGroup 嵌套。


4.ViewStub 的作用是什么
ViewStub 是轻量级占位控件，默认不加载，需时通过 inflate () 加载布局，适合条件显示的 UI（如空数据提示），减少初始布局加载时间。


37.自定义 View 的基本流程是什么
继承 View 或现有控件，重写构造方法（解析属性），重写 onMeasure（测量尺寸），重写 onDraw（绘制内容），必要时重写 onTouchEvent（处理触摸）。


5.View 的测量模式有哪些
EXACTLY（精确尺寸，如 match_parent 或固定值）、AT_MOST（最大尺寸，如 wrap_content）、UNSPECIFIED（无限制，如 ScrollView 中的子 View）。


6.SurfaceView 和普通 View 的区别是什么
SurfaceView 有独立绘图表面，在子线程绘制，适合高频刷新（如视频、游戏）；普通 View 在主线程绘制，刷新频繁会卡顿。

7.RecyclerView 相比 ListView 有哪些优势
RecyclerView 更灵活，通过 LayoutManager 支持多种布局（线性、网格、瀑布流）、强制使用 ViewHolder、支持动画、可自定义 ItemDecoration 和 ItemAnimator。


8.RecyclerView 的优化策略有哪些
复用 ViewHolder、减少布局层级、图片懒加载（滑动时暂停）、使用 DiffUtil 更新数据、设置固定高度（setHasFixedSize (true)）、优化 onBindViewHolder（避免耗时操作）。


9.DiffUtil 的作用是什么
DiffUtil 通过比对新旧数据集，计算差异并更新变化的 Item，替代 notifyDataSetChanged ()，减少不必要的刷新，提升性能和动画效果。


10.如何在 ScrollView 中如何嵌入 ListView 
通常情况下我们不会在 ScrollView 中嵌套 ListView。
在 ScrollView 添加一个 ListView 会导致 listview 控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。所以需要通过 listview 中的 item 数量去计算 listview 的显示高度，从而使其完整展示。
现阶段最好的处理的方式是： 自定义 ListView，重载 onMeasure()方法，设置全部显示。


绘制原理
40.View 的绘制流程包含哪三个核心步骤
测量（onMeasure，确定尺寸）→ 布局（onLayout，确定位置）→ 绘制（onDraw，绘制内容）。父 View 会递归调用子 View 的这三个方法。


41.什么是 View 树，系统如何遍历 View 树进行绘制
View 树是由 ViewGroup 和 View 组成的层级结构。系统通过深度优先遍历，先绘制父 View，再绘制子 View，确保子 View 覆盖在父 View 之上。


42.硬件加速的原理是什么，哪些情况下需要关闭
硬件加速利用 GPU 处理绘制，提升性能。但部分绘制操作（如 PathEffect、LayerType.SOFTWARE）不支持硬件加速，需在 View 级别关闭。


43.什么是 Choreographer
Choreographer 协调 UI 绘制、输入和动画，与屏幕刷新率同步（通常 60fps），确保绘制在每一帧的正确时机执行，避免卡顿。


44.View 的事件分发机制中三个核心方法是什么
dispatchTouchEvent（分发事件）、onInterceptTouchEvent（拦截事件，仅 ViewGroup 有）、onTouchEvent（处理事件）。流程：先分发，再判断是否拦截，最后处理。


45.如何解决滑动冲突
常见方案：在父 View 的 onInterceptTouchEvent 中根据滑动方向判断是否拦截；或子 View 通过 requestDisallowInterceptTouchEvent () 请求父 View 不拦截。


7.Android 中的动画有哪几类，它们的特点和区别是什么 
视图动画，或者说补间动画。只是视觉上的一个效果，实际view属性没有变化，性能好，但是支持方式少。
属性动画，通过变化属性来达到动画的效果，性能略差，支持点击等事件。android 3.0
帧动画，通过drawable一帧帧画出来。
Gif动画，原理同上，canvas画出来。 


三、性能优化
内存优化
1.什么是OOM
Out Of Memory，内存耗尽


46.常见的内存泄漏场景有哪些
单例持有 Activity 上下文、未取消的监听器（如 BroadcastReceiver、EventBus）、Handler 匿名内部类持有 Activity 引用、资源未关闭（流、Cursor）、静态集合持有对象。


47.什么是内存抖动，如何解决
内存抖动指短时间频繁创建和回收对象（如循环中创建对象），导致 GC （垃圾回收）频繁触发。解决：复用对象、使用对象池、避免在 onDraw () 中创建对象。


48.LRU 缓存机制的原理是什么
LRU算法优先淘汰最久未使用的对象，通过 LinkedHashMap 实现，适用于图片缓存（如 Glide）、内存数据缓存。


49.如何优化 Bitmap 的内存占用
根据控件尺寸加载对应分辨率图片（inSampleSize）、使用适当格式（如 WebP）、及时回收（recycle ()）、使用缓存、通过 Glide 等库自动管理。


50.弱引用、软引用和强引用的区别是什么
强引用（默认）：GC 不会回收；软引用（SoftReference）：内存不足时回收，适合缓存；弱引用（WeakReference）：GC 触发时回收，适合临时对象。


7.android 应用对内存是如何限制的,我们应该如何合理使用内存
为了维持多任务环境的正常运行，Android 会为每个应用的堆大小设置硬性上限。不同设备的确切堆大小上限取决于设备的总体可用 RAM 大小。如果应用在达到堆容量上限后尝试分配更多内存，则可能会收到 OutOfMemoryError。
合理使用内存
a.避免全局变量
b.避免使用枚举（Enum）
c.使用弱引用
d.使用ArrayMap/SparseArray代替hashmap
e.使用分页加载数据
f.减少bitmap的内存占用
g.图片的内存管理：使用Glide等库来管理图片的加载和内存缓存
h.及时回收资源：例如Cursor、流等，使用后应及时关闭
i.使用LeakCanary检测内存泄漏


启动与响应优化
51.冷启动、热启动和温启动的区别是什么
冷启动：进程首次创建，需初始化 Application 和 Activity，耗时最长；热启动：进程存在，Activity 未销毁，直接恢复；温启动：进程存在，但 Activity 需重建，耗时介于两者之间。


52.如何优化应用启动速度
减少 Application onCreate () 中的初始化（延迟非核心任务）、优化首屏布局（减少层级、避免过度绘制）、使用启动主题避免白屏、异步加载数据、启用 R8 混淆缩减代码。


53.什么是 ANR，如何避免
ANR（应用无响应）指主线程阻塞超过一定时间（输入事件 5 秒，广播 10 秒，服务 20 秒）。避免：耗时操作放子线程；使用 AsyncTask/HandlerThread/Coroutine；减少布局复杂度；避免在主线程中执行可能会阻塞线程的操作，如网络请求、数据库操作等。


54.如何检测 ANR 问题
通过 Logcat 查看 ANR 日志（data/anr/traces.txt）、使用 Android Vitals 监控、自定义 ANR 监控（如通过 Handler 定时检测主线程响应）。


55.启动优化中如何使用 IdleHandler
IdleHandler 在主线程空闲时执行，可用于延迟初始化非核心组件（如统计、推送），避免占用启动时间：Looper.myQueue ().addIdleHandler (() -> { ...; return false; })。


网络优化
59.如何优化网络请求
合并请求、使用缓存（OkHttp 缓存）、压缩数据（Gzip）、图片懒加载、使用 Retrofit+OkHttp 的拦截器统一处理、避免重复请求、根据网络类型（WiFi / 移动网络）调整策略。


60.列表滑动卡顿的常见原因有哪些
布局层级过深、Item 布局复杂、onBindViewHolder 中执行耗时操作、图片未优化（过大或未缓存）、过度绘制、主线程做网络 / IO 操作。


进程线程
1.android实现线程间通信的四种常见方式
a.通过Handler机制
b.runOnUiThread方法
c.View.post(Runnable r) 
d.AsyncTask

2.AsyncTask使用在哪些场景，它的缺陷是什么，如何解决
场景：AsyncTask 运用的场景就是我们需要进行一些耗时的操作，耗时操作完成后更新主线程，或者在操作过程中对主线程的UI进行更新。
缺陷：AsyncTask中维护着一个长度为128的线程池，同时可以执行5个工作线程，还有一个缓冲队列，当线程池中已有128个线程，缓冲队列已满时，如果 此时向线程提交任务，将会抛出RejectedExecutionException。
解决：由一个控制线程来处理AsyncTask的调用判断线程池是否满了，如果满了则线程睡眠否则请求AsyncTask继续处理。


3.子线程中能不能 new handler,为什么
不能
在没有调用 Looper.prepare()的时候不能创建 Handler，如果在子线程中直接 new Handler()会抛出异常 java.lang.RuntimeException: Can'tcreate handler inside thread that has not called


4.Handler消息机制中，一个looper是如何区分多个Handler的
因为在msg入队列时，会将msg.target设置一个handler，处理消息的时候，也会调用msg对象的target去处理消息 


2.如何开启多进程 ， 应用是否可以开启N个进程 
在AndroidMenifest中给四大组件指定属性android:process开启多进程模式
在内存允许的条件下可以开启N个进程


3.Android跨进程通信的方式有哪些
Binder
Messenger
AIDL
ContentProvider
Socket
SharedPreferences
EventBus


4.Binder机制的作用和原理
Binder是Android系统中用于实现跨进程通信的机制。它通过一种轻量级的进程间通信方式，允许一个进程向另一个进程发送消息。
Binder的工作原理主要包括以下几个步骤：
Binder驱动程序：Binder机制依赖于Linux内核中的Binder驱动程序，它负责处理进程间通信的底层细节。
Binder通信的建立：在Android系统中，每个进程都有一个Binder通信的服务端和客户端。当一个进程需要向另一个进程发送消息时，它首先通过Binder驱动程序获取对方进程的Binder通信实体。
Binder通信的传输：消息通过Binder通信实体传输，可以是数据、函数调用等。Binder采用了共享内存的方式传输数据，效率较高。
Binder通信的接收：接收方进程接收到消息后，会通过Binder驱动程序将消息传递给相应的进程组件，例如服务、活动等。
通过以上步骤，Binder机制实现了Android系统中的跨进程通信，为开发者提供了一种方便、高效的通信方式。


5.什么是AIDL 
a.AIDL(Android Interface Definition Language，Android接口定义语言)：如果在一个进程中要调用另一个进程中对象的方法，可使用AIDL生成可序列化的参数，AIDL会生成一个服务端对象的代理类，通过它客户端实现间接调用服务端对象的方法。
b.AIDL的本质是系统提供了一套可快速实现Binder的工具。


6.Android多线程实现方式
1、基础使用
        继承Thread类，实现Runnable接口，Handler
2、复合使用
        AsyncTask，HandlerThread，IntentService
3、高级使用
        线程池（ThreadPool）

7.线程同步的几种方法 
Synchronized：给一个方法增加synchronized修饰符之后就可以使它成为同步方法
volatile：volatile关键字为域变量的访问提供了一种免锁机制
使用局部变量实现线程同步(ThreadLocal)：ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
使用阻塞队列实现线程同步(LinkedBlockingQueue): 队列是先进先出的顺序。


8.TCP、UDP 
TCP三次握手，四次挥手
TCP和UDP区别
                       TCP                                UDP
是否连接       面向连接                 面向非连接
传输可靠性    可靠                     会丢包，不可靠
应用场景      传输数据量大             传输量小
速度               慢                                     快


9.什么是Socket
即通过Socket，我们才能在Andorid平台上通过 TCP/IP协议进行开发
Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）


10.Retrofit是如何将子线程切换到主线程
defaultCallbackExecutor 内部其实调用的是 new MainThreadExecutor() ，很清楚的看到， handler.post(r) 内部使用Handler将响应抛到了主线程。这就是Retrofit将子线程切换到主线程的核心所在。


四、数据存储与安全
数据存储
61.Android 中有哪些数据存储方式
SharedPreferences（键值对，轻量）、文件存储（内部 / 外部存储）、SQLite 数据库（结构化数据，Room 封装）、ContentProvider（跨应用共享）、网络存储（服务器）。


62.SharedPreferences 的使用注意事项是什么
不适合存储大量数据、线程不安全（多进程需用 MODE_MULTI_PROCESS，已废弃，建议用 ContentProvider）、commit () 同步提交，apply () 异步提交（可能丢失）。


63.Room 框架的优势是什么
Room 是 SQLite 的封装，提供编译时语法检查、简化 CRUD 操作、支持 LiveData 和 RxJava 响应式查询、减少模板代码，避免手写 SQL 错误。


64.内部存储和外部存储的区别是什么
内部存储：私有（仅本应用访问）、应用卸载时删除、无需权限；外部存储：分为公共目录（所有应用可访问）和私有目录（Android/data/ 包名，卸载删除），访问公共目录需权限。


65.Android 10 的分区存储（Scoped Storage）是什么
分区存储限制应用直接访问外部存储根目录，需通过 MediaStore 访问公共媒体文件，或使用应用私有目录，增强用户隐私保护，Android 11 后强制启用。


安全与权限
66.Android 权限分为哪几类
正常权限（如 INTERNET，自动授予）、危险权限（如 CAMERA，需动态申请）、特殊权限（如 SYSTEM_ALERT_WINDOW，需跳转设置页面申请）。


67.如何请求危险权限
检查是否已授权（checkSelfPermission ()），未授权则请求（requestPermissions ()），在 onRequestPermissionsResult () 中处理结果，必要时显示权限说明（shouldShowRequestPermissionRationale ()）。


68.如何加密存储敏感数据
使用 AndroidKeystore 存储密钥、AES 加密数据、SharedPreferences 加密（如 EncryptedSharedPreferences）、避免明文存储密码（用哈希 + 盐值）。


69.如何防止应用被反编译
启用 Proguard/R8 混淆代码、使用加固工具（如 360 加固）、敏感逻辑用 C++ 实现（NDK）、检测调试状态（Debug.isDebuggerConnected ()）。


70.网络传输中如何保证数据安全
使用 HTTPS（TLS）、证书校验（避免中间人攻击）、数据加密后传输、敏感参数不放在 URL 中、使用 OKHttp 的 SSLSocketFactory 配置安全连接。


五、框架与第三方库
Jetpack 组件
71.ViewModel 的作用是什么
ViewModel 存储与 UI 相关的数据，生命周期独立于 Activity/Fragment，解决屏幕旋转等配置变化时的数据丢失问题，通常与 LiveData 配合使用。


72.LiveData 的特点是什么
LiveData 是可观察的数据持有者，能感知生命周期，仅在 Activity/Fragment 处于活跃状态时通知更新，避免内存泄漏，支持数据粘性（新观察者能收到旧数据）。


73.DataBinding 的优势是什么
DataBinding 将布局与数据直接绑定，减少 findViewById () 代码，支持双向绑定（@={}），可在 XML 中写简单逻辑，提升开发效率。


74.WorkManager 的作用是什么
WorkManager 管理后台任务（如同步数据），兼容不同 Android 版本，根据设备状态（充电、网络、空闲）智能调度，支持周期性任务和链式任务。


75.Navigation 组件如何管理页面跳转
Navigation 通过导航图（nav_graph.xml）集中管理页面关系，支持 Fragment 和 Activity 跳转，自动处理回退栈，可通过 Safe Args 传递参数，避免类型错误。


76.请详细说明Navigation组件的使用场景以及与传统Fragment事务的比较。
导航图的可视化： 使用导航图直观展示应用中的导航流程，方便理解和修改。
类型安全： 利用Kotlin的类型安全特性，减少在导航时的错误。
生命周期感知： 自动处理Fragment的生命周期，避免了一些常见的生命周期相关问题


77.请解释Navigation组件的作用，并介绍Navigation组件的核心组件以及它们之间的关系。
作用： Navigation组件用于实现应用内的导航结构，使得从一个目的地（Destination）到另一个目的地的导航变得更加容易管理和统一。
核心组件：
NavGraph（导航图）： 包含应用中所有目的地和它们之间的导航关系。
NavController（导航控制器）： 管理导航操作的控制器，负责管理与目的地的交互。
NavDestination（导航目的地）： 表示导航图中的一个页面或操作，定义了目的地的属性和行为。


78.请详细说明ViewModel的作用，并介绍使用ViewModel的主要优势。
ViewModel的作用在于解决Android应用中活动和碎片（Fragment）的生命周期问题。它允许数据在屏幕旋转等配置更改时存活，并确保数据在不同组件之间共享而不丢失。
主要优势包括：
生命周期感知：ViewModel能够感知与UI相关的生命周期变化，确保数据存活时间比短暂的UI组件更长。
数据共享：通过ViewModel，可以在不同的UI组件之间共享和管理数据，避免重复加载或丢失数据。
状态保存：ViewModel在配置变更时保持其状态，例如屏幕旋转，避免重新加载数据和执行耗时操作。


79.详细说明LiveData和ViewModel的工作原理，并讨论在实际项目中如何解决常见的生命周期问题。
LiveData是一种可观察的数据持有者，ViewModel用于存储和管理与用户界面相关的数据。
深入理解包括：
LiveData的粘性事件： 了解postValue和setValue的区别，以及如何避免LiveData的粘性事件在特定场景中引发的问题。
ViewModel的存活周期： 使用ViewModel正确处理配置变化，保证数据在屏幕旋转等情况下不丢失。
LiveData和View绑定： 结合DataBinding，实现LiveData与View之间的绑定，确保数据的实时更新。


80.请对比LiveData和Observable，分析它们在Android应用中的应用场景，以及在何种情况下选择使用哪种。 
LiveData和Observable都是用于实现响应式编程的工具，但有一些关键区别：
生命周期感知： LiveData是生命周期感知的，它会在观察者（通常是UI组件）的生命周期内自动启动和停止。这使得在处理UI数据时更加安全，避免了潜在的内存泄漏。
背压处理： Observable在RxJava中通常使用背压策略来处理数据流，而LiveData则通过生命周期感知来实现反应式响应，避免了背压问题。


81.请解释Paging库的基本原理，并提出在处理大型数据集时如何进行性能优化。
Paging库通过在RecyclerView中异步加载数据，实现了对大型数据集的高效处理。性能优化的关键在于以下几个方面：
DataSource的定制： 实现自定义的DataSource，根据实际需求定制加载规则，如预加载、缓存等。
数据缓存策略： 使用BoundaryCallback来实现边界回调，可以在数据边界到达时触发预加载，减少用户等待时间。
DiffUtil的合理使用： 配合PagedListAdapter，使用DiffUtil来计算并刷新列表的差异，减少不必要的数据刷新，提高界面流畅度。


82.请解释WorkManager的工作原理，并讨论在需要复杂任务调度时如何设计和实现。
 WorkManager是一种用于在后台执行任务的库，它建立在JobScheduler、AlarmManager和JobIntentService之上。在高级任务调度中，我们可以：
自定义Worker： 实现Worker类以执行具体任务，并通过Constraints来定义任务的触发条件，如网络状态、电量等。
任务链和顺序执行： 使用OneTimeWorkRequest和WorkContinuation来构建任务链，实现复杂任务的顺序执行。
灵活的重试机制： 结合BackoffPolicy，实现任务的灵活重试策略，应对不同类型的任务失败情况。


83.请解释Hilt依赖注入框架的优势，以及在Android应用中的使用方式。
Hilt作为依赖注入框架，具有以下优势:
简化依赖注入： Hilt通过标准化依赖注入的方式，大大简化了在Android应用中的依赖注入过程，减少了样板代码。
与Jetpack集成： Hilt与其他Jetpack组件无缝集成，使得在使用其他Jetpack库时能够更加方便地进行依赖注入。
通过在应用类上添加@HiltAndroidApp注解，以及使用@Inject注解来标记依赖关系，等多种注解，可以轻松地实现依赖注入。


84.在使用Room数据库时，有哪些性能优化的手段可以提高数据库访问的效率？
Room数据库的性能优化手段包括：
合理使用索引： 根据查询需求创建合适的索引，提高查询效率。
批量操作： 使用@Transaction注解将多个操作放在同一个事务中，减少数据库事务的开销。
异步查询： 在后台线程执行查询操作，避免在主线程中执行耗时的数据库操作，防止ANR。
适度使用Room的内存缓存： 使用@Query注解的LiveData返回值时，Room会自动在内存中维护缓存，但要注意不要过度依赖，以免造成内存浪费。


网络与图片
76.Retrofit 的工作原理是什么
Retrofit 通过动态代理将接口方法转换为 OKHttp 请求，解析注解（如 @GET、@POST）生成请求参数和 URL，通过 ConverterFactory 解析响应数据（如 Gson），CallAdapter 转换返回类型（如 Observable）。


77.OkHttp 的拦截器有什么作用
拦截器用于在请求发送前或响应返回后处理（如添加公共参数、日志打印、缓存控制、token 过期重试），分为应用拦截器和网络拦截器。


78.Glide 的三级缓存机制是什么
内存缓存（LruCache + 弱引用，最快）→ 磁盘缓存（原始图片 + 处理后图片，持久化）→ 网络请求（最慢）。加载图片时依次检查三级缓存，未命中则从网络获取。


79.Glide 如何实现图片的高效加载
自动根据 ImageView 尺寸加载对应分辨率图片、支持内存和磁盘缓存、使用线程池管理加载任务、生命周期感知（避免 Activity 销毁后仍加载）、自动回收资源。


80.RxJava 的背压是什么
背压指生产者发送数据速度快于消费者处理速度的问题，RxJava 通过 Flowable 和 Subscriber 支持背压策略（如缓冲、丢弃、错误），控制数据流速。


81.Lifecycle 的实现原理 
Lifecycle的实现原理是基于观察者模式，主要依赖于三个类：LifecycleOwner、LifecycleRegistry和LifecycleObserver。
1、LifecycleOwner在创建时会创建一个Lifecycle实例。
2、Lifecycle实例本质就是LifecycleRegistry，它会将自己的状态变化通知给所有注册的观察者。
3、LifecycleObserver在收到状态变化通知后，可以根据状态变化执行相应的操作。


82.LiveData的优点
1、确保界面符合数据状态
LiveData 遵循观察者模式。当底层数据发生变化时，LiveData 会通知 **Observer**对象。您可以整合代码以在这些 Observer 对象中更新界面。这样一来，您无需在每次应用数据发生变化时更新界面，因为观察者会替您完成更新。
2、不会发生内存泄漏
观察者会绑定到Lifecycle对象，并在其关联的生命周期遭到销毁后进行自我清理。
不会因 Activity 停止而导致崩溃
如果观察者的生命周期处于非活跃状态（如返回栈中的Activity），则它不好接受任何LiveData事件
3、不再需要手动处理生命周期
界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。
4、数据始终保持最新状态
如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。
5、适当的配置更改
如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。
6、共享资源
您可以使用单例模式扩展 LiveData对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。


六、高级特性与现代开发
Compose 相关
81.什么是Compose
Jetpack Compose是一种用于构建用户界面的现代工具包，专为Android应用程序开发而设计。它使用Kotlin编程语言，允许开发者使用声明式方式构建用户界面，而不是传统的XML布局文件。


82.什么是 Composable 函数
Composable 是 Compose 中用于构建 UI 的函数，用 @Composable 注解标记，可嵌套调用，系统会根据状态变化自动重组（重新执行）需要更新的部分。


83.Compose 的重组机制是什么
重组是 Compose 根据状态变化重新执行部分 UI 代码的过程，只更新变化的组件，而非整个 UI 树，通过 remember 保存状态，避免不必要的重组。


84.如何在 Compose 中管理状态
使用 remember 保存临时状态，viewModel () 获取 ViewModel 中的状态，状态提升（将子组件状态移至父组件）实现状态共享，使用 StateFlow 管理跨组件状态。


85.Compose 和传统 View 如何混编
在 Compose 中用 AndroidView 包裹传统 View，在传统布局中用 ComposeView 承载 Compose 内容，适合渐进式迁移。


86.Compose 中的副作用有哪些处理方式
LaunchedEffect（协程中执行副作用，如网络请求）、DisposableEffect（需要清理的副作用，如注册监听器）、SideEffect（每次重组都执行，如更新全局状态）。


系统特性与适配
87.Android 12 的 Material You 设计语言有哪些特点
支持动态色彩（从壁纸提取主题色）、圆角设计、新的组件样式（如 Button、Card）、手势导航增强、应用启动动画规范。


88.如何适配折叠屏设备
检测屏幕状态（展开 / 折叠）、使用 Jetpack WindowManager 获取屏幕信息、避免硬编码尺寸、测试多窗口模式、适配不同折叠形态（如内折、外折）。


89.如何适配暗黑模式
在 styles.xml 中定义 DayNight 主题，使用？attr / 引用主题属性，在 res/values-night 目录下定义暗黑模式资源，支持用户手动切换模式。


90.Android 13 对权限有哪些变更
通知权限需动态申请、媒体权限细分（图片、视频、音频）、剪贴板访问限制、精确位置权限需单独申请。


91.什么是应用休眠（App Hibernation）
Android 13 引入，长期未使用的应用会被标记为休眠状态，系统限制其后台活动和网络访问，需在 Manifest 中声明豁免或提示用户打开应用解除休眠。


七、测试与调试
92.单元测试和 instrumentation 测试有何区别
单元测试（如 JUnit）在本地 JVM 运行，测试独立组件，速度快；instrumentation 测试（如 Espresso）在设备 / 模拟器运行，测试组件交互，依赖 Android 框架。


93.Espresso 框架的作用是什么
Espresso 用于 UI 测试，提供简洁 API（onView ().perform ().check ()），自动处理主线程同步，支持匹配器（Matcher）定位 View，验证 UI 状态。


94.Mockito 的作用是什么？
Mockito 是 mocking 框架，用于创建模拟对象（如网络请求、数据库），隔离测试对象，验证方法调用，设置返回值，简化单元测试。


95.如何测试异步代码
使用 CountDownLatch 等待异步完成、RxJava 的 TestSubscriber、Coroutine 的 runBlockingTest、Espresso 的 IdlingResource 处理异步加载。


96.什么是 UI Automator
UI Automator 用于跨应用 UI 测试，可操作系统控件（如通知栏、设置），适合端到端测试，支持通过文本、描述等定位元素。


调试与工具
97.ADB 有哪些常用命令
安装应用（adb install）、卸载（adb uninstall）、查看日志（adb logcat）、重启（adb reboot）、查看设备（adb devices）、截图（adb shell screencap）、录屏（adb shell screenrecord）。


98.Android Profiler 的主要功能是什么
Android Profiler 包含 CPU（分析方法耗时）、内存（检测泄漏）、网络（监控请求）、电量（分析耗电）分析工具，实时监控应用性能。


99.如何使用 Layout Inspector 分析布局问题
Layout Inspector 可实时查看应用的 View 树结构、属性和测量信息，识别过度绘制、层级过深等问题，支持 3D 视图查看布局层次。


100.什么是 systrace
systrace 用于分析系统级性能问题，记录 CPU 调度、UI 渲染、进程状态等信息，生成 HTML 报告，可识别掉帧、锁竞争等瓶颈。


101.LeakCanary 的工作原理是什么
LeakCanary 在 Activity/Fragment 销毁后，通过弱引用检测是否被回收，未回收则触发 GC 并分析堆内存，生成泄漏路径报告，帮助定位内存泄漏。


八.Android其他
1.android 的系统架构 
Android系统架构分为四层架构，从高到低分别是应用层，应用框架层，系统运行层和Linux内核层。


2.架构模式
MVC(Model View Controller) 
通过controller的控制去操作model层的数据，并且返回给view层展示。
缺点：
a.View与Model之间还存在依赖关系，Controller很重很复杂，开发，测试，维护都需要花大量的精力
b.Activity即是View又是Controller，维护起来更难。
c.适合单人开发。

MVP(Model View Presenter)
view层和model层完全隔离和解耦，presenter层充当桥梁。presenter层去操作model层，并且将数据返回给view层，整个过程中view层和model层完全没有联系。
优点：
a、view层和model层完全隔离。
b、activity和fragment不再是controller层，而是纯粹的view层。
缺点：
虽然是MVC模式的演变，但Presenter依旧很‘重’很复杂。

MVVM（Model View ViewModel）
view层和viewmodel层是相互绑定的关系，更新viewmodel层的数据的时候，view层会相应的变动ui。同步逻辑是交由Binder做的，Model变更View跟着变更，只需要保证Model的正确性，View就正确。
优点：
a.解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。
b.ViewModle易于单元测试。


3.Android的事件分发机制
Android事件分发机制的本质：事件从哪个对象发出，经过哪些对象，最终由哪个对象处理了该事件。
Android事件的分发顺序：Activity（Window） -> ViewGroup -> View
事件分发dispatchTouchEvent：
        如果事件分发返回true，表示改事件在本层不再进行分发且已经在事件分发自身中被消费了。至此，事件已经完结。
        如果事件分发返回 false，表明事件在本层不再继续进行分发，并交由上层控件的onTouchEvent方法进行消费。
        dispatchTouchEvent无论返回true还是false，事件都不再进行分发，

只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，
事件拦截onInterceptTouchEvent：
        如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；
        如果返回结果是false；则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。

事件响应onTouchEvent：
        如果onTouchEvent返回true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结，将不会进行后续的冒泡。
        如果onTouchEvent返回false，事件在onTouchEvent中处理后继续向上层View冒泡，且有上层View的onTouchEvent进行处理。


4.Framework 工作方式及原理
所有的框架都是基于反射和配置文件（manifest）的。


5.Android 屏幕适配
a.dp 原生方案
dp 的优势也主要体现在相同尺寸，不同分辨率的设备的适配效果。对于不同尺寸不同分辨率的设备，dp 的适配效果就差强人意了
b.sw 限定符适配方案
android 会识别屏幕可用高度和宽度的最小尺寸的 dp 值，然后根据识别到的结果去 资源文件 中寻找对应限定符的文件夹下的资源文件


6.什么是Context,它有哪些作用？
Context是Android中所有应用组件的基础，提供了访问应用环境和系统服务的接口。其作用包括：
        •加载资源。
        •启动Activity、Service、发送Broadcast。
        •获取系统服务，如LocationManager、NotificationManager等。
        •访问应用文件系统和偏好设置。


7.Context有哪两种类型 ，区别是什么
application context 和 activity context。
        1、application context取的是这个应用程序的Context，它的生命周期伴随应用程序的存在而存在；而activity context取的是当前Activity的Context，它的生命周期则只能存活于当前Activity
        2、不要让生命周期长的对象引用activity context， 对于生命周期长的对象，可以使用application context


8Android中的消息机制（Handler, Looper, MessageQueue）是如何工作的？
此机制允许在主线程中处理来自其他线程的消息。
        •MessageQueue：维护一个消息列表，按顺序处理消息。
        •Looper：在每个线程中创建，用于循环遍历MessageQueue，取出并分发消息给Handler处理。
        •Handler：发送消息到MessageQueue，并在消息出队时处理消息。通过post(Runnable)或sendMessage(Message)方法实现。

9Looper中的Loop()方法不能导致主线程卡死
死循环并不是导致主线程卡死的真正原因, 真正的原因是死循环后面的事件没有得到分发。 Looper 中的 loop()方法, 他的作用就是从消息队列MessageQueue 中不断地取消息, 然后将事件分发出去 ， 所以不会造成卡顿或者ANR。


10.Android垃圾回收机制的算法
​1、标记清除算法
当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。
2、标记整理算法
和标记清除一样，标记整理的第一个阶段也是对垃圾对象进行标记，区别主要在第二个步骤，即整理。所谓的整理就是避免之前标记清除时的内存碎片的问题，他就会在清除的过程中，会把可用的对象向前给他移动，这样的话让内存更为紧凑，这就是整理的过程。整理之后，就能发现内存变的更紧凑了，即连续的空间就更多了，这样就不会造成内存碎片。
3、复制算法
复制算法比较特殊，他把内存区域划分成了大小相等的两块儿区域，左边区域称之为FROM，右边区域称之为TO，其中TO这个区域始终空闲着，即里面一个对象都没有。
1.先扫谁是垃圾 2.把好的不是垃圾的放进空的to里面 3.交换to和form的位置 4.删除垃圾
4、分代垃圾回收
        在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成垃圾收集的过程。
        而老年代的对象存活率是比较高的，且没有额外的空间对它进行分配，所以我们必须选择 “标记-清除” 或 “标记-整理” 算法进行垃圾收集。


11.AMS、PMS和WMS
AMS（Activity Manager Service）作为活动管理器服务，它主要负责管理和跟踪所有应用程序的活动任务和生命周期。当一个应用程序被打开时，AMS会启动该应用程序的进程，并给应用程序分配处理器资源和内存。当应用程序不再处于前台或后台，或者当系统内存不足时，AMS会终止或杀死这个应用程序的进程。
PMS（PackageManager Service）作为包管理器服务，主要负责在Android设备上安装、管理和卸载应用程序。当一个新的应用程序被安装时，PMS将识别应用程序的所有组件（如Activity、Service和Broadcast Receiver等），并为这些组件分配相应的权限。同时，PMS还监控已安装应用程序的状态，确保应用程序的完整性和安全性。
WMS（Window Manager Service）作为窗口管理器服务，它主要负责管理Android设备上的窗口视图，并控制应用程序的界面和正确的显示和输入。WMS负责管理应用程序窗口的位置、大小和布局，照顾多任务操作和应用程序之间的切换，从而确保用户界面稳定、流畅和一致。


12.AMS是如何启动的
阶段1：SystemServer 进程创建 Android 运行环境。AMS 运行在 SystemServer 进程中，它的许多工作依赖于该运行环境
createSystemContext() -> new ActvityThread()->attach ->getSystemContext ->createSystemContext

阶段2：启动 AMS，主要进行一些初始化工作 
new ActivityManagerService()
start()

阶段3：将 SystemServer 进程纳入到 AMS 的进程管理体系中 
//将framework-res.apk的信息加入到SystemServer进程的LoadedApk中
//构建SystemServer进程的ProcessRecord，保存到AMS中，以便AMS进程统一管理
setSystemProcess() 
installSystemProviders() //安装SystemServer进程中的SettingsProvider.apk

 阶段4：AMS 启动完成，通知服务或应用完成后续的工作，或直接启动一些进程


13.什么是Force Close,什么情况会导致Force Close ,如何避免,能否捕获导致其的异常
forceclose，意为强行关闭，当前应用程序发生了冲突 
原因：抛出运行时异常时就会导致Force Close，比如空指针、数组越界、类型转换异常等等。
避免：编写程序时，要思维缜密，在可能出现异常的地方都作相应的处理，增强程序的健壮性。
捕获：可以通过logcat查看抛出异常的代码出现的位置，然后到程序对应代码中进行修改。


14.如何打开res/raｗ目录中的数据库文件
不能直接打开res/raw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。 


15.什么是序列化，什么是反序列化，为什么需要使用序列化和反序列化
序列化：将对象转换为可传输的二进制流的过程。
反序列化：把字节序列恢复成对象的过程。 
原因：方便数据的传输


九.Java相关
1.什么是反射机制，反射机制的应用场景有哪些
Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；                                                                                                     
应用场景：                                                                                                      
1. 逆向代码，例如反编译                                                                                                      
2. 与注解相结合的框架，如 Retrofit                                                                                        
3. 单纯的反射机制应用框架，例如 EventBus（事件总线）                                
4. 动态生成类框架 例如Gson


2.谈一谈Java成员变量，局部变量和静态变量的创建和回收时机
成员变量:生命周期伴随类对象,类对象回收时回收，存在堆里。                                 
局部变量:方法调用时创建，方法结束时被标记为可回收，存在栈里                             
静态变量:不回收，在方法区随着类的加载而加载，随着类的消失而消失。


3.内部类都有哪些
静态内部类、非静态内部类、局部内部类、匿名内部类


4.线程池的好处
a.线程池的重用： 线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。
b.控制线程池的并发数。并发数：系统同时能处理的请求数量。


5.HashMap和ArrayList如何扩容
HashMap的扩容是通过创建一个新的、更大的哈希表，并将旧哈希表中的所有元素重新插入到新哈希表中来实现的。 
ArrayList是动态数组，它可以根据需要动态增长或缩小。当我们向ArrayList中添加元素时，如果当前元素个数已经达到了数组的容量上限，ArrayList就会进行扩容操作。


6.Java有哪些集合
Collection 集合体系
用于存储单个对象（元素） 的集合，分为List、 Set 和 Queue 三类。
List（有序、可重复）
Set（无序、不可重复）
Queue（队列结构）

Map 集合体系
用于存储键值对（Key-Value）的集合，Key 唯一，Value 可重复。
HashMap 无序，键和值都可以为 null。
LinkedHashMap 使用哈希表 + 链表，保持插入顺序，或按访问顺序排序。
TreeMap 使用红黑树实现，键自然排序或自定义排序。
Hashtable类似 HashMap，但线程安全，性能较差。
ConcurrentHashMap  线程安全的 HashMap，用于高并发场景，性能优于 Hashtable。

